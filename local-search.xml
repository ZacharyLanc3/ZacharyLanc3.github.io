<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="/2024/04/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/04/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用了WordPress、Halo等博客框架之后，决定将博客框架转向Hexo，首先WordPress和Halo的显得较为臃肿，对使用VPS的配置要求较高，难免会增加成本，并且编写markdown文件然后由配置生成页面的成就感明显大于在框架后台编写文章发布，所以我选择转向静态博客，至于Hugo和Hexo之间倒是很难抉择，考虑到在初期对性能没有那么大的要求，并且hexo的插件更加丰富，所以暂时选择hexo作为主题框架，如果后期有性能上的要求，也会考虑转向Hugo。</p><p>接下来我将介绍我搭建Hexo博客的历程，参考了<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>，以及一些其他人的教程。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h4><p>我使用的是windows，在<a href="https://git-scm.com/download">官网</a>直接下载Git的安装程序，然后按步骤安装即可，可以在cmd输入git –version来检测是否安装成功，接下来我们在任何文件目录或者桌面右键打开Git Bash，然后就可以使用Git Bash（比cmd更好用的命令行工具，里面的命令基本类似于Linux，使用过Linux的用户可以很好上手）输入命令了。</p><h4 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h4><p>在<a href="https://nodejs.cn/download/">Node.js 中文官网 </a>下载安装即可，随后打开Git Bash，输入命令<code>node -v</code>和<code>npm -v</code>检查是否安装成功。</p><h4 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h4><p>推荐阅读<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>，里面有详细的安装和配置教程，这里简单介绍一下如何安装。</p><p>首先创建一个文件夹，用于存放项目文件以及文章，之后hexo的操作都在此文件夹中，进入到此文件夹中。</p><ol><li>安装hexo:<code>npm install -g hexo-cli</code></li><li>检查安装：<code>hexo v</code></li><li>进入到博客文件夹目录中： <code>cd PATH/TO/BLOG</code></li><li>初始化hexo项目： <code>hexo init</code></li><li>生成项目：<code>hexo g</code></li><li>启动本地服务器检查项目生成：<code>hexo s</code>;然后点击命令行中出现的地址跳转到浏览器。</li></ol><h3 id="将项目部署到服务器"><a href="#将项目部署到服务器" class="headerlink" title="将项目部署到服务器"></a>将项目部署到服务器</h3><h4 id="一、使用github-pages"><a href="#一、使用github-pages" class="headerlink" title="一、使用github pages"></a>一、使用github pages</h4><p>github是一个远程代码仓库，其提供的pages功能是用于快速展示代码的demo，其提供了静态页面服务器以及免费的域名，我们可以使用这个功能来实现由hexo生成的静态页面的部署。</p><ol><li><p>注册github账号，并创建一个名为“github用户名.github.io”的仓库</p></li><li><p>在本地的Git Bash中初始化你的用户名和邮箱</p><p><code>git config --global user.name &quot;你的Github用户名&quot;</code></p><p><code>git config --global user.email &quot;你的Github邮箱&quot;</code></p></li><li><p>ssh连接（本地仓库连接到远程仓库）</p><ul><li><p>本地下载Github部署插件：<code>npm install hexo-deployer-git --save</code></p></li><li><p>本地生成获取密钥：</p><p>生成密钥：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code></p><p>获取复制密钥： <code>cat ~/.ssh/.id_rsa.pub </code> 复制命令行中显示的密钥值。</p></li><li><p>github填写密钥值：打开github-&gt;头像-&gt;setting-&gt;SSH and GPG keys,新建ssh，将复制的密钥值粘贴进去即可。</p></li><li><p>验证ssh连接： ssh -T <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;</a></p></li></ul><p>在hexo文件夹中的_config.yml中配置一下基本配置，具体参考<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>。</p><p>然后使用1.生成项目：<code>hexo g </code>；2.部署项目：<code>hexo d</code></p><p>这样项目就被远程部署到github pages上，可以使用域名直接在浏览器中打开了（部署后可能需要等几分钟）。</p></li></ol><h4 id="二、使用VPS"><a href="#二、使用VPS" class="headerlink" title="二、使用VPS"></a>二、使用VPS</h4><p>直接使用Github pages的访问速度较慢，可以考虑自己购置云服务器（VPS）来部署博客项目，下面这几点就不做详细介绍了。</p><ul><li>选购VPS，开放80以及443端口。（略）</li><li>在自己的VPS中选择创建一个目录作为项目目录。（略）</li><li>购置一个域名，并解析到自己的VPS。（略）</li></ul><p>由于部署的是静态页面，所以我们唯一要做的就是安装配置服务器，这里我选择nginx服务器。</p><p>安装配置nginx的教程也可以参考<a href="https://docshome.gitbook.io/nginx-docs">Nginx中文文档</a>，这里也只做基本介绍。</p><ol><li><p>安装nginx</p><p>考虑到VPS大多是Linux系统，所以使用自带的软件包管理器（例如yum、apt）就可以安装nginx。例如<code>apt update </code>  <code>apt install nginx</code> 即可。</p></li><li><p>配置nginx</p><p>安装的nginx配置文件一般位于&#x2F;etc&#x2F;nginx下，使用文本编辑器打开配置文件<code>vim /etc/nginx/nginx.conf</code> ,在http中添加一个server。server的配置可参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>listen 80;<br>listen [::]:80;<br>server_name yourdomin;#填自己的域名或者IP<br>root /PATH/TO/YOUR/BLOG;#你的博客项目存放位置<br>location / &#123;<br>root /PATH/TO/YOUR/BLOG;<br>index index.html index.htm;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完后可以使用 <code>nginx -t</code> 测试配置，使用<code>nginx -s reload</code>或<code>systemctl restart nginx</code>重启nginx，配置即可生效。</p><p>现在浏览器中输入IP或者域名就会跳转nginx服务器代理的页面。</p></li><li><p>申请ssl证书</p><p>不使用ssl加密的话，首先网站会不安全，其次很多浏览器会不支持。所以需要申请ssl证书。这里采用acme的脚本获取ssl证书并且自动更新证书。</p><ol><li><p>下载并执行acme.sh</p><p><code>curl https://get.acme.sh | sh</code></p></li><li><p>重启命令行</p></li><li><p>检测是否执行成功（即检测是否执行脚本中的创建链接）</p><p><code>acme.sh -h</code>(出现版本号即成功)</p></li><li><p>签发证书（这里只介绍http验证，其余验证方式可以参考<a href="https://zhuanlan.zhihu.com/p/347064501">这篇文章</a>）</p><p><code>acme.sh --register-account -m 你的邮箱 --issue -d 你的域名 --webroot 项目地址</code></p></li><li><p>将证书导入到nginx文件夹，选择你想要将证书储存的位置,输入到下列命令中的&#x2F;path&#x2F;to&#x2F;keyfile&#x2F;in&#x2F;nginx&#x2F;和&#x2F;path&#x2F;to&#x2F;fullchain&#x2F;nginx&#x2F;中， 直接使用脚本命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">acme.sh --installcert -d 你的域名 \<br><br>--key-file       /path/to/keyfile/in/nginx/youdomin.key  \<br><br>--fullchain-file /path/to/fullchain/nginx/fullchain.cer \<br><br>--reloadcmd     &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><p>然后再次配置nginx</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nginx">   <span class="hljs-section">server</span> &#123;<br>   <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>   <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span>;<br>   <span class="hljs-attribute">server_name</span> yourdomin;<span class="hljs-comment">#填自己的域名或者IP</span><br>   <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)</span> https://<span class="hljs-variable">$_server_name</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<span class="hljs-comment">#跳转https</span><br>   <span class="hljs-attribute">root</span> /PATH/TO/YOUR/BLOG;<span class="hljs-comment">#你的博客项目存放位置</span><br>   <span class="hljs-section">location</span> / &#123;<br>   <span class="hljs-attribute">root</span> /PATH/TO/YOUR/BLOG;<br>   <span class="hljs-attribute">index</span> index.html index.htm;<br>   &#125;<br>   &#125;<br>   <span class="hljs-section">server</span> &#123;<br>   <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>   <span class="hljs-attribute">server_name</span> yourdomin;<span class="hljs-comment">#填自己的域名或者IP</span><br>   <span class="hljs-attribute">root</span> /PATH/TO/YOUR/BLOG;<span class="hljs-comment">#你的博客项目存放位置</span><br>   <span class="hljs-attribute">ssl_certificate</span> /path/to/fullchain/nginx/fullchain.cer;<span class="hljs-comment">#申请的ssl证书</span><br>   <span class="hljs-attribute">ssl_certificate_key</span> /path/to/keyfile/in/nginx/youdomin.key;<span class="hljs-comment">#生成的密钥</span><br>   <br><span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">10m</span>;<br>   <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>   <span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br>   <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>   <br>   <span class="hljs-section">location</span> / &#123;<br>   <span class="hljs-attribute">root</span> /PATH/TO/YOUR/BLOG;<br>   <span class="hljs-attribute">index</span> index.html index.htm;<br>   &#125;<br>   <br>   &#125;<br></code></pre></td></tr></table></figure><p>重启nginx即可。</p></li></ol></li><li><p>将项目文件传输至VPS。</p><p>为了减少VPS的负担，我们把Hexo生成器安装在自己的个人电脑上，但是这样不可避免就产生了一个问题，如何将生成的hexo项目传到VPS的项目文件夹中，目前本人使用了如下一些方法。</p><ol><li><p>直接使用WinSCP将项目文件copy到VPS中。</p><p>这个方法很傻瓜式，只用使用WinSCP登录到VPS，然后将hexo&#x2F;Public中的项目文件粘贴过去即可。但是传输速率较慢，操作不够优雅。</p></li><li><p>git</p><p>既然hexo有命令能将本地项目push到远程仓库，那我们可以</p><ul><li>使用<code>hexo d</code>部署到Github上</li><li>然后在VPS中安装Git，将你的项目所在目录使用<code>git init</code>初始化为本地仓库，</li><li>使用<code>git pull 远程仓库地址</code>即可将项目部署到VPS中</li></ul></li></ol><p>关于这个问题，肯定还有更优雅的方式，我也会在网上借鉴别人的方案然后补充到此文章中。</p></li></ol><h3 id="主题的选择"><a href="#主题的选择" class="headerlink" title="主题的选择"></a>主题的选择</h3><p>主题是各有爱好的选择，这里也不作过多介绍，hexo官网有主题的安装文档，一般的主题也都有自己的使用文档，安装起来也很方便。</p><p>我选择的是<a href="https://hexo.fluid-dev.com/docs/">Fluid主题</a>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此博客部署已经结束，编写博客的流程：</p><ul><li>markdown编辑器中撰写文章</li><li>生成public项目（<code>hexo clean</code>,<code>hexo g</code>）</li><li>部署到服务器</li></ul>]]></content>
    
    
    <categories>
      
      <category>经验教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习（一）</title>
    <link href="/2024/03/06/Spring%E5%AD%A6%E4%B9%A01/"/>
    <url>/2024/03/06/Spring%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h3 id="简介-使用及学习"><a href="#简介-使用及学习" class="headerlink" title="简介&amp;使用及学习"></a>简介&amp;使用及学习</h3><p>Spring现在包含着Spring boot、Spring Cloud等一系列技术，但是作为Spring的初学者，我们需要学习Spring Framework，这是Spring最初的设计框架，所以以下先用Spring代替Spring Framework。</p><p>Spring Framework主要包括几个模块：</p><ul><li>支持IoC和AOP的容器；</li><li>支持JDBC和ORM的数据访问模块；</li><li>支持声明式事务的模块；</li><li>支持基于Servlet的MVC开发；</li><li>支持基于Reactive的Web开发；</li><li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li></ul><p>Spring（Spring Framework）主要就包括IoC和AOP两个方面。</p><p>Spring最初是以写配置的方式来开发，然后出现了注解功能，我们在日常开发中通常是使用写注解的方式。但是注解实际上是写配置的方式的变形，所以我们想要了解原理，仍然要学习如何写配置。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><ul><li>最底层是一个核心容器</li><li>然后是AOP和Aspects</li><li>然后是数据访问（包含一个高效的事务控制）</li><li>然后是Web开发</li></ul><h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><h4 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h4><p>核心概念：IoC、DI</p><p>解决的问题：</p><ul><li>代码耦合度偏高（当修改一个功能时需要重新使用一个对象，于是跟此对象关联的所有地方都要进行修改）</li></ul><p>解决方案：</p><ul><li>不主动产生对象，转为由外部提供对象</li></ul><p>技术方案：</p><ul><li>IoC（控制反转）</li></ul><p>IoC就是一个产生对象的容器，IoC负责管理大量的对象的创建和初始化，被创建或被管理的对象在容器中统称为Bean</p><p>若IoC中的对象存在依赖关系，可以直接在容器中进行绑定，这就是DI（依赖注入）技术</p><h4 id="如何实现："><a href="#如何实现：" class="headerlink" title="如何实现："></a>如何实现：</h4><h5 id="IoC的实现"><a href="#IoC的实现" class="headerlink" title="IoC的实现"></a>IoC的实现</h5><ol><li>首先确定自己需要管理的类</li><li>在resources中创建Spring配置文件</li><li>编写配置 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; ...&gt;&lt;/bean&gt;</code> </li><li>获取IoC容器<code>ApplicationContext ctx = new ClassPathXmlApplicationContext(创建的配置文件)</code> </li><li>获取Bean <code>ctx.getBean</code> 方法</li></ol><h5 id="DI的实现"><a href="#DI的实现" class="headerlink" title="DI的实现"></a>DI的实现</h5><ol><li><p>创建其他对象不再使用new方法</p></li><li><p>创建一个set方法</p></li><li><p>在配置文件中添加依赖配置</p><p><code>&lt;property name=&quot;属性中的名称&quot; ref=&quot;其他bean的名称&quot;/&gt;</code></p></li></ol><h5 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h5><p>bean的基础属性有id、class，也可以使用name为bean添加别名；</p><p>默认创建的bean是单例，可以在配置中添加scope&#x3D;”prototype”设置为非单例，可以复用的对象都可以以单例形式交给IoC管理。</p><h5 id="bean是如何创建的"><a href="#bean是如何创建的" class="headerlink" title="bean是如何创建的"></a>bean是如何创建的</h5><p>本质上bean也是用类的构造方法来创建bean的，但是是使用java的反射机制实行的（private构造方法也可以创建），默认是使用无参构造方法实现的，需要提供无参构造方法。</p><p>bean也有其他方式实例化，比如使用静态工厂的方式。在使用静态工厂的方式创建对象时，需要在配置中将类改为工厂类名，然后通用再加一个<code>factory-method=&quot;&quot;</code> 来实现。</p><p>还有使用实例工厂的方式，这种还需要再实例化这个工厂，比较复杂。配置时要先把工厂的bean配置出来，然后配置要使用的bean的factory-method和factory-bean。</p><p>后来Spring改进了实例工厂的方式，需要接口FactoryBean，这种方式在配置时就不用配置完工厂bean后再配置要使用的bean，只需要配置工厂bean。这种方法可以在工厂类中使用isSingleto()方法修改是否是单例。</p><h5 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h5><p>在配置中使用init-method&#x3D;””  destoy-method&#x3D;”” 配置bean的生命周期，在类中写init和destroy方法。（或者使用接口的方式）</p><p>关闭容器的方式(方法是ClassPathXmlApplication类中的方法，需要创建此类型的IoC容器)</p><ul><li><code>close</code></li><li><code>registerShutdownHook()</code></li></ul><h5 id="依赖注入的实现"><a href="#依赖注入的实现" class="headerlink" title="依赖注入的实现"></a>依赖注入的实现</h5><ol><li><p>使用set方法，然后配置<code>&lt;porperty name=&quot;&quot; ref=&quot;&quot;/&gt;</code></p><p>如果是基本数据类型或者String则property中的ref换成valuie即可</p></li><li><p>构造器注入。将构造方法改成带参数的构造方法，配置中使用 <code>&lt;constructor name=&quot;形参名&quot; ref/value=&quot;&quot;/&gt;</code> 配置，<code>name=&quot;&quot;</code>可以换成index和type索引属性。 </p></li><li><p>依赖的自动装配。 在bean的配置中加上 <code>autowire=&quot;&quot;</code> 可完成自动装配，需要注意的是类中的set方法不可省去，但是省去了写 <code>property</code>这一行。关于参数byType指按类型装配，一个类只能有一个对象&#x2F;bean，这种情况需要使用参数byName,Name是对象名，一般是使用byType。自动装配只能应用于引用类型，不能应用于基本类型。自动装配的优先级低于手动装配。</p></li><li><p>集合注入</p><ul><li><p>数组：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>list:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>set:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--set中重复的部分会过滤掉--&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>props(properties)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h5 id="加载其他的properties文件"><a href="#加载其他的properties文件" class="headerlink" title="加载其他的properties文件"></a>加载其他的properties文件</h5><ol><li>开启context命名空间</li><li>使用context命名空间加载指定properties文件</li><li>使用${ }读取加载的属性值</li></ol><h4 id="容器补充"><a href="#容器补充" class="headerlink" title="容器补充"></a>容器补充</h4><ul><li><p>从文件系统加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<span class="hljs-string">&quot;path/to/.xml&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>加载多个配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;name1.xml&quot;</span>,<span class="hljs-string">&quot;name2.xml&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>获取bean的方式补充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>)<span class="hljs-comment">//根据名称</span><br><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>,BookDao.class)<span class="hljs-comment">//根据名称并指定类</span><br><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(BookDao.class)<span class="hljs-comment">//根据类</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="半注解开发"><a href="#半注解开发" class="headerlink" title="半注解开发"></a>半注解开发</h3><p>半注解开发是Spring2的时候推出的开发模式，在Spring3后出现了纯注解开发的模式。具体实现如下：</p><ol><li>在要配置的bean前加上<code>@Component</code>注解，</li><li>在配置文件中通过组件扫描加载bean</li><li><code>@Service</code>用于业务层的bean <code>@Repository</code>用于数据层的bean <code>@Controller</code>用于表现层的bean</li></ol><h3 id="纯注解开发"><a href="#纯注解开发" class="headerlink" title="纯注解开发"></a>纯注解开发</h3><h4 id="创建IoC容器和bean"><a href="#创建IoC容器和bean" class="headerlink" title="创建IoC容器和bean"></a>创建IoC容器和bean</h4><ol><li><p>新建一个配置类，使用此配置类替代xml配置文件，加上注解<code>@Configuration</code>（代替注解的说明）和<code>@ComponentScan(Bean模块)</code> （代替组件扫描）</p></li><li><p>初始化容器的语句不再是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;name.xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>而是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(配置类的名称.class)<br></code></pre></td></tr></table></figure></li></ol><h4 id="配置bean"><a href="#配置bean" class="headerlink" title="配置bean"></a>配置bean</h4><ul><li>修改非单例：加注解 <code>@Scope(&quot;prototype&quot;)</code> </li><li>设置初始化和销毁方法：<code>@PostConstruct</code> <code>@PreDestroy</code></li><li>自动装配实现依赖注入 <code>@Autowired</code> ,并且此时不用再创建set方法实现注入了。</li><li>想要按名称注入就需要在<code>@Autowired</code> 后加上 <code>@Qualifier(&quot;name&quot;)</code> </li><li>注入基本类型和String类型 加注解 <code>@Value(&quot;值&quot;)</code></li></ul><h4 id="加载外部配置文件"><a href="#加载外部配置文件" class="headerlink" title="加载外部配置文件"></a>加载外部配置文件</h4><ol><li>在配置类中加上标签 <code>@PropertySource(&quot;name.properties&quot;)</code> </li><li>注入时使用<code>$&#123;外部配置文件中的变量名&#125;</code></li></ol><h4 id="第三方bean管理"><a href="#第三方bean管理" class="headerlink" title="第三方bean管理"></a>第三方bean管理</h4><ol><li>在配置类中新建一个方法获得想要的bean</li><li>加上@Bean注解</li><li>一般的要把这个方法写在新的配置类中，然后在主配置类中加上注解 <code>@import()</code>  或者 <code>@ComponentScan()</code></li></ol><p>想要在第三方bean中进行依赖注入，如果是简单类型使用@Value注解，如果是引用类型的bean直接在获取bean的方法加上形参即可。</p><h3 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><p>在不修改原始设计的基础上进行功能增强，符合Spring无侵入式设计理念。</p><h5 id="常用名词："><a href="#常用名词：" class="headerlink" title="常用名词："></a>常用名词：</h5><ul><li>连接点：程序执行过程中的任意位置</li><li>切入点：匹配连接点的式子</li><li>通知：在切入点进行的操作</li><li>通知类：定义通知的类</li><li>切面：描述通知和切入点的对应关系</li></ul><h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><ol><li><p>导入坐标（pom.xml）</p></li><li><p>制作连接点方法</p></li><li><p>制作共性功能</p></li><li><p>定义切入点</p><p>加上@Pointcut(“切入点表达式”)注解</p></li><li><p>绑定切入点和通知的关系</p><p>加上在何处执行共性方法的注解，如@Before(“切入点”)</p></li></ol><p>在通知类前加上@Component和@Aspect注解，然后在配置类前加上@EnableAspectJAutoProxy注解，即启动切面编程。</p><h5 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h5><p>标准格式：</p><p>动作关键字 （访问修饰符 返回值  包名.类&#x2F;接口.方法名(参数) 异常名） </p><p>在AOP切入点表达式中可以使用通配符</p><ul><li>*： 单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀出现</li><li>..： 多个连续的任意符号，可以独立出现，常用于简化包名和参数的书写</li><li>+： 专用于匹配子类类型</li></ul><h5 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h5><ul><li><p>前置通知：<code>@Before(&quot;pt()&quot;)</code></p></li><li><p>后置通知：<code>@After(&quot;pt()&quot;)</code></p></li><li><p>环绕通知：<code>@Around(&quot;pt()&quot;)</code>，通知上要有<code>pjp.proceed()</code>;表示对原方法的调用，并且通知方法需要有返回值。</p><p>标准写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwables&#123;<br>原始方法前想要执行的代码<br><span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed();<span class="hljs-comment">//表示调用了原始方法</span><br>原始方法后想要执行的代码<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>无异常运行完成后：<code>@AfterReturning(&quot;pt()&quot;)</code></p></li><li><p>抛出异常后：<code>@AfterThrowing(&quot;pt()&quot;)</code></p></li></ul><h5 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h5><ul><li>获取切入点方法的参数<ol><li>JointPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedJointPoint：适用于环绕通知</li></ol></li><li>获取切入点方法返回值<ol><li>返回后通知</li><li>环绕通知</li></ol></li><li>获取切入点方法运行异常信息<ol><li>抛出异常后通知</li><li>环绕通知</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用学习</title>
    <link href="/2024/03/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Git是一个分布式版本控制系统（分布式指版本库储存在个人设备中，集中式的版本库位于中央服务器中，需要联网才能使用）。</p><h4 id="安装使用流程"><a href="#安装使用流程" class="headerlink" title="安装使用流程"></a>安装使用流程</h4><ul><li><p>Linux上直接使用软件包管理器安装或者编译安装即可，windows上直接在官网下载安装程序即可。</p></li><li><p>命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>创建版本库</p><p>*注意这里的操作是测试使用，如果想工作某个项目一般是先创建一个远程库，然后克隆至本地</p><ol><li><p>创建一个目录</p></li><li><p>git init即可将此目录变为可管理的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init [name]<br></code></pre></td></tr></table></figure></li><li><p>将文件添加到仓库（在仓库目录中执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add 文件名<br></code></pre></td></tr></table></figure></li><li><p>用命令<code>git commit</code>告诉Git，把文件提交到仓库（-m命令为此次提交填写说明<code>-m &quot;xxx&quot;</code>）</p></li></ol></li></ul><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ol><li><p><code>git status</code> 查看仓库状态</p></li><li><p><code>git diff &lt;文件名&gt;</code> 查看修改区别</p></li><li><p>版本回退</p><ul><li>使用 <code>git log</code> 查看更新日志</li><li>使用 <code>git reset --hard &lt;版本号&gt;  </code> (版本号可以是commit id的前几位，也可以用HEAD、HEAD^、HEAD~n(往上n个版本))</li><li><code>gut reflog</code> 查看每一次命令</li></ul></li><li><p>撤销修改</p><ul><li><code>git checkout -- &lt;文件名&gt;</code> 使工作区的修改撤回至暂存区&#x2F;(如果暂存区没有)版本库。（工作区是指你修改文件的地方，使用<code>git add</code>后修改被传至暂存区，使用<code>git commit</code>后修改被传至版本库）（应用于修改了还没add）</li><li><code>git restore &lt;file&gt;</code> 将文件的修改撤销至暂存区，并清空暂存区（应用于修改了还没add且上一次add还没commit）</li><li><code>git restore --satge &lt;file&gt;</code> 将暂存区清空但不修改工作区修改（应用于add了还没commit）暂存区&lt;–工作区</li><li><code>git reset HEAD &lt;file&gt;</code> 将暂存区的修改撤销至版本库（应用于add了还没commit）暂存区&lt;–版本库</li></ul></li><li><p>删除文件</p><ul><li><p>删除工作区文件后继续删除版本库中文件</p><p><code>git rm &lt;file&gt;</code>  then  <code>git commit -m &lt;message&gt;</code> </p></li><li><p>删除工作区后恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -- test.txt<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>有两种选择</p><ol><li>搭建一个个人的Git服务器，这种服务器别人无法看见；</li><li>使用Github免费仓库，其他人可见。</li></ol><h5 id="关联至github远程仓库"><a href="#关联至github远程仓库" class="headerlink" title="关联至github远程仓库"></a>关联至github远程仓库</h5><p>需要使用SSH加密所有需要获取个人的私钥和公钥，若没有则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>将本地仓库与远程仓库关联，在本地仓库中执行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:用户名/远程库名.git<br></code></pre></td></tr></table></figure><p>把本地库的所有内容推送到远程库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br></code></pre></td></tr></table></figure><p>上述指令是将本地的分支master推送到远程仓库origin。-u是关联的参数。</p><h5 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h5><p><code>git remote -v </code>查看远程库信息</p><p><code>git remote rm &lt;name&gt;</code> 解除与远程库的绑定关系</p><h5 id="git-clone-克隆远程库"><a href="#git-clone-克隆远程库" class="headerlink" title="git clone 克隆远程库"></a>git clone 克隆远程库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:用户名/远程库名.git<br></code></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><h5 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev 或者<br>$ git switch -c dev<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch dev<br>$ git checkout dev<br>或者<br>$ git branch dev<br>$ git switch master<br></code></pre></td></tr></table></figure><p>使用 <code>git branch</code> 查看当前分支</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>先切换回master分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev<br></code></pre></td></tr></table></figure><p>若是master和dev都修改过，则可能产生冲突，需要先消除冲突。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev<br></code></pre></td></tr></table></figure><h5 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br>$ git stash apply//不删除stash内容恢复现场<br>$ git stash drop//删除stash内容<br>$ git stash pop//删除stash内容恢复现场<br></code></pre></td></tr></table></figure><h5 id="将相同的修改应用至别的分支"><a href="#将相同的修改应用至别的分支" class="headerlink" title="将相同的修改应用至别的分支"></a>将相同的修改应用至别的分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commit ID&gt;<br></code></pre></td></tr></table></figure><h5 id="丢弃一个没有被合并过的分支"><a href="#丢弃一个没有被合并过的分支" class="headerlink" title="丢弃一个没有被合并过的分支"></a>丢弃一个没有被合并过的分支</h5><p>通过<code>git branch -D &lt;name&gt;</code>强行删除</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><ul><li><p>切换到分支然后<code>git tag &lt;name&gt;</code></p></li><li><p>使用 <code>git tag</code> 查看所有标签</p></li><li><p>给某次提交打标签 <code>$ git tag &lt;name&gt; &lt;commit ID&gt;</code> </p></li><li><p>删除标签 <code>git tag -d &lt;name&gt;</code> </p></li><li><p>推送某个标签到远程<code>git push origin &lt;tagname&gt;</code> 或者 <code>git push oringin --tags</code> </p></li><li><p>从远程删除标签 <code>$ git push origin :refs/tags/&lt;name&gt;</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
