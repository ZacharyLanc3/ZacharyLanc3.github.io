<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL基本学习</title>
    <link href="/2024/03/06/MySQL%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/06/MySQL%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>按照数据结构组织储存管理数据的仓库叫做数据库，每个数据有自己的 API 创建、访问、管理、搜索和复制所保存的数据。不直接将数据储存在文件中的原因是在文件中的数据速度较慢。</p><p>MySQL是关系型数据库，具有以下特点：</p><ul><li>数据以表格的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ul><p>安装好后即可使用</p><h5 id="连接至本机MySQL数据库"><a href="#连接至本机MySQL数据库" class="headerlink" title="连接至本机MySQL数据库"></a>连接至本机MySQL数据库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><h5 id="连接至指定数据库"><a href="#连接至指定数据库" class="headerlink" title="连接至指定数据库"></a>连接至指定数据库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -h 主机名 -u 用户名 -p<br></code></pre></td></tr></table></figure><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <br>          (host, <span class="hljs-keyword">user</span>, password, <br>           select_priv, insert_priv, update_priv) <br>           <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;guest&#x27;</span>, <br>           PASSWORD(<span class="hljs-string">&#x27;guest123&#x27;</span>), <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">DELETE</span>,<span class="hljs-keyword">CREATE</span>,<span class="hljs-keyword">DROP</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> TUTORIALS.<span class="hljs-operator">*</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;zara&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;zara123&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> DATABASES；<br></code></pre></td></tr></table></figure><h5 id="显示指定数据库的所有表"><a href="#显示指定数据库的所有表" class="headerlink" title="显示指定数据库的所有表"></a>显示指定数据库的所有表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> use 数据库名;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> TABLES;<br></code></pre></td></tr></table></figure><h5 id="显示数据表的属性"><a href="#显示数据表的属性" class="headerlink" title="显示数据表的属性"></a>显示数据表的属性</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> COLUMNS <span class="hljs-keyword">FROM</span> runoob_tbl;<br></code></pre></td></tr></table></figure><h5 id="显示数据表的详细索引信息"><a href="#显示数据表的详细索引信息" class="headerlink" title="显示数据表的详细索引信息"></a>显示数据表的详细索引信息</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> runoob_tbl;<br></code></pre></td></tr></table></figure><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE 数据库名;<br></code></pre></td></tr></table></figure><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database <span class="hljs-operator">&lt;</span>数据库名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习</title>
    <link href="/2024/03/06/Spring%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/06/Spring%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="简介-使用及学习"><a href="#简介-使用及学习" class="headerlink" title="简介&amp;使用及学习"></a>简介&amp;使用及学习</h3><p>Spring现在包含着Spring boot、Spring Cloud等一系列技术，但是作为Spring的初学者，我们需要学习Spring Framework，这是Spring最初的设计框架，所以以下先用Spring代替Spring Framework。</p><p>Spring Framework主要包括几个模块：</p><ul><li>支持IoC和AOP的容器；</li><li>支持JDBC和ORM的数据访问模块；</li><li>支持声明式事务的模块；</li><li>支持基于Servlet的MVC开发；</li><li>支持基于Reactive的Web开发；</li><li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li></ul><p>Spring（Spring Framework）主要就包括IoC和AOP两个方面。</p><p>Spring最初是以写配置的方式来开发，然后出现了注解功能，我们在日常开发中通常是使用写注解的方式。但是注解实际上是写配置的方式的变形，所以我们想要了解原理，仍然要学习如何写配置。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><ul><li>最底层是一个核心容器</li><li>然后是AOP和Aspects</li><li>然后是数据访问（包含一个高效的事务控制）</li><li>然后是Web开发</li></ul><h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><h4 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h4><p>核心概念：IoC、DI</p><p>解决的问题：</p><ul><li>代码耦合度偏高（当修改一个功能时需要重新使用一个对象，于是跟此对象关联的所有地方都要进行修改）</li></ul><p>解决方案：</p><ul><li>不主动产生对象，转为由外部提供对象</li></ul><p>技术方案：</p><ul><li>IoC（控制反转）</li></ul><p>IoC就是一个产生对象的容器，IoC负责管理大量的对象的创建和初始化，被创建或被管理的对象在容器中统称为Bean</p><p>若IoC中的对象存在依赖关系，可以直接在容器中进行绑定，这就是DI（依赖注入）技术</p><h4 id="如何实现："><a href="#如何实现：" class="headerlink" title="如何实现："></a>如何实现：</h4><h5 id="IoC的实现"><a href="#IoC的实现" class="headerlink" title="IoC的实现"></a>IoC的实现</h5><ol><li>首先确定自己需要管理的类</li><li>在resources中创建Spring配置文件</li><li>编写配置 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; ...&gt;&lt;/bean&gt;</code> </li><li>获取IoC容器<code>ApplicationContext ctx = new ClassPathXmlApplicationContext(创建的配置文件)</code> </li><li>获取Bean <code>ctx.getBean</code> 方法</li></ol><h5 id="DI的实现"><a href="#DI的实现" class="headerlink" title="DI的实现"></a>DI的实现</h5><ol><li><p>创建其他对象不再使用new方法</p></li><li><p>创建一个set方法</p></li><li><p>在配置文件中添加依赖配置</p><p><code>&lt;property name=&quot;属性中的名称&quot; ref=&quot;其他bean的名称&quot;/&gt;</code></p></li></ol><h5 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h5><p>bean的基础属性有id、class，也可以使用name为bean添加别名；</p><p>默认创建的bean是单例，可以在配置中添加scope&#x3D;”prototype”设置为非单例，可以复用的对象都可以以单例形式交给IoC管理。</p><h5 id="bean是如何创建的"><a href="#bean是如何创建的" class="headerlink" title="bean是如何创建的"></a>bean是如何创建的</h5><p>本质上bean也是用类的构造方法来创建bean的，但是是使用java的反射机制实行的（private构造方法也可以创建），默认是使用无参构造方法实现的，需要提供无参构造方法。</p><p>bean也有其他方式实例化，比如使用静态工厂的方式。在使用静态工厂的方式创建对象时，需要在配置中将类改为工厂类名，然后通用再加一个<code>factory-method=&quot;&quot;</code> 来实现。</p><p>还有使用实例工厂的方式，这种还需要再实例化这个工厂，比较复杂。配置时要先把工厂的bean配置出来，然后配置要使用的bean的factory-method和factory-bean。</p><p>后来Spring改进了实例工厂的方式，需要接口FactoryBean，这种方式在配置时就不用配置完工厂bean后再配置要使用的bean，只需要配置工厂bean。这种方法可以在工厂类中使用isSingleto()方法修改是否是单例。</p><h5 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h5><p>在配置中使用init-method&#x3D;””  destoy-method&#x3D;”” 配置bean的生命周期，在类中写init和destroy方法。（或者使用接口的方式）</p><p>关闭容器的方式(方法是ClassPathXmlApplication类中的方法，需要创建此类型的IoC容器)</p><ul><li><code>close</code></li><li><code>registerShutdownHook()</code></li></ul><h5 id="依赖注入的实现"><a href="#依赖注入的实现" class="headerlink" title="依赖注入的实现"></a>依赖注入的实现</h5><ol><li><p>使用set方法，然后配置<code>&lt;porperty name=&quot;&quot; ref=&quot;&quot;/&gt;</code></p><p>如果是基本数据类型或者String则property中的ref换成valuie即可</p></li><li><p>构造器注入。将构造方法改成带参数的构造方法，配置中使用 <code>&lt;constructor name=&quot;形参名&quot; ref/value=&quot;&quot;/&gt;</code> 配置，<code>name=&quot;&quot;</code>可以换成index和type索引属性。 </p></li><li><p>依赖的自动装配。 在bean的配置中加上 <code>autowire=&quot;&quot;</code> 可完成自动装配，需要注意的是类中的set方法不可省去，但是省去了写 <code>property</code>这一行。关于参数byType指按类型装配，一个类只能有一个对象&#x2F;bean，这种情况需要使用参数byName,Name是对象名，一般是使用byType。自动装配只能应用于引用类型，不能应用于基本类型。自动装配的优先级低于手动装配。</p></li><li><p>集合注入</p><ul><li><p>数组：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>list:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>set:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--set中重复的部分会过滤掉--&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>props(properties)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h5 id="加载其他的properties文件"><a href="#加载其他的properties文件" class="headerlink" title="加载其他的properties文件"></a>加载其他的properties文件</h5><ol><li>开启context命名空间</li><li>使用context命名空间加载指定properties文件</li><li>使用${ }读取加载的属性值</li></ol><h4 id="容器补充"><a href="#容器补充" class="headerlink" title="容器补充"></a>容器补充</h4><ul><li><p>从文件系统加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<span class="hljs-string">&quot;path/to/.xml&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>加载多个配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;name1.xml&quot;</span>,<span class="hljs-string">&quot;name2.xml&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>获取bean的方式补充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>)<span class="hljs-comment">//根据名称</span><br><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>,BookDao.class)<span class="hljs-comment">//根据名称并指定类</span><br><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(BookDao.class)<span class="hljs-comment">//根据类</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="半注解开发"><a href="#半注解开发" class="headerlink" title="半注解开发"></a>半注解开发</h3><p>半注解开发是Spring2的时候推出的开发模式，在Spring3后出现了纯注解开发的模式。具体实现如下：</p><ol><li>在要配置的bean前加上<code>@Component</code>注解，</li><li>在配置文件中通过组件扫描加载bean</li><li><code>@Service</code>用于业务层的bean <code>@Repository</code>用于数据层的bean <code>@Controller</code>用于表现层的bean</li></ol><h3 id="纯注解开发"><a href="#纯注解开发" class="headerlink" title="纯注解开发"></a>纯注解开发</h3><h4 id="创建IoC容器和bean"><a href="#创建IoC容器和bean" class="headerlink" title="创建IoC容器和bean"></a>创建IoC容器和bean</h4><ol><li><p>新建一个配置类，使用此配置类替代xml配置文件，加上注解<code>@Configuration</code>（代替注解的说明）和<code>@ComponentScan(Bean模块)</code> （代替组件扫描）</p></li><li><p>初始化容器的语句不再是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;name.xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>而是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(配置类的名称.class)<br></code></pre></td></tr></table></figure></li></ol><h4 id="配置bean"><a href="#配置bean" class="headerlink" title="配置bean"></a>配置bean</h4><ul><li>修改非单例：加注解 <code>@Scope(&quot;prototype&quot;)</code> </li><li>设置初始化和销毁方法：<code>@PostConstruct</code> <code>@PreDestroy</code></li><li>自动装配实现依赖注入 <code>@Autowired</code> ,并且此时不用再创建set方法实现注入了。</li><li>想要按名称注入就需要在<code>@Autowired</code> 后加上 <code>@Qualifier(&quot;name&quot;)</code> </li><li>注入基本类型和String类型 加注解 <code>@Value(&quot;值&quot;)</code></li></ul><h4 id="加载外部配置文件"><a href="#加载外部配置文件" class="headerlink" title="加载外部配置文件"></a>加载外部配置文件</h4><ol><li>在配置类中加上标签 <code>@PropertySource(&quot;name.properties&quot;)</code> </li><li>注入时使用<code>$&#123;外部配置文件中的变量名&#125;</code></li></ol><h4 id="第三方bean管理"><a href="#第三方bean管理" class="headerlink" title="第三方bean管理"></a>第三方bean管理</h4><ol><li>在配置类中新建一个方法获得想要的bean</li><li>加上@Bean注解</li><li>一般的要把这个方法写在新的配置类中，然后在主配置类中加上注解 <code>@import()</code>  或者 <code>@ComponentScan()</code></li></ol><p>想要在第三方bean中进行依赖注入，如果是简单类型使用@Value注解，如果是引用类型的bean直接在获取bean的方法加上形参即可。</p><h3 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><p>在不修改原始设计的基础上进行功能增强，符合Spring无侵入式设计理念。</p><h5 id="常用名词："><a href="#常用名词：" class="headerlink" title="常用名词："></a>常用名词：</h5><ul><li>连接点：程序执行过程中的任意位置</li><li>切入点：匹配连接点的式子</li><li>通知：在切入点进行的操作</li><li>通知类：定义通知的类</li><li>切面：描述通知和切入点的对应关系</li></ul><h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><ol><li><p>导入坐标（pom.xml）</p></li><li><p>制作连接点方法</p></li><li><p>制作共性功能</p></li><li><p>定义切入点</p><p>加上@Pointcut(“切入点表达式”)注解</p></li><li><p>绑定切入点和通知的关系</p><p>加上在何处执行共性方法的注解，如@Before(“切入点”)</p></li></ol><p>在通知类前加上@Component和@Aspect注解，然后在配置类前加上@EnableAspectJAutoProxy注解，即启动切面编程。</p><h5 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h5><p>标准格式：</p><p>动作关键字 （访问修饰符 返回值  包名.类&#x2F;接口.方法名(参数) 异常名） </p><p>在AOP切入点表达式中可以使用通配符</p><ul><li>*： 单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀出现</li><li>..： 多个连续的任意符号，可以独立出现，常用于简化包名和参数的书写</li><li>+： 专用于匹配子类类型</li></ul><h5 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h5><ul><li><p>前置通知：<code>@Before(&quot;pt()&quot;)</code></p></li><li><p>后置通知：<code>@After(&quot;pt()&quot;)</code></p></li><li><p>环绕通知：<code>@Around(&quot;pt()&quot;)</code>，通知上要有<code>pjp.proceed()</code>;表示对原方法的调用，并且通知方法需要有返回值。</p><p>标准写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwables&#123;<br>原始方法前想要执行的代码<br><span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed();<span class="hljs-comment">//表示调用了原始方法</span><br>原始方法后想要执行的代码<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>无异常运行完成后：<code>@AfterReturning(&quot;pt()&quot;)</code></p></li><li><p>抛出异常后：<code>@AfterThrowing(&quot;pt()&quot;)</code></p></li></ul><h5 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h5><ul><li>获取切入点方法的参数<ol><li>JointPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedJointPoint：适用于环绕通知</li></ol></li><li>获取切入点方法返回值<ol><li>返回后通知</li><li>环绕通知</li></ol></li><li>获取切入点方法运行异常信息<ol><li>抛出异常后通知</li><li>环绕通知</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java网络编程和javaweb</title>
    <link href="/2024/03/06/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&amp;javaweb/"/>
    <url>/2024/03/06/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&amp;javaweb/</url>
    
    <content type="html"><![CDATA[<h4 id="java网络编程"><a href="#java网络编程" class="headerlink" title="java网络编程"></a>java网络编程</h4><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>一个IP地址用于唯一标识一个网络接口（Network Interface）</p><h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><ul><li>应用层，提供应用程序之间的通信；</li><li>表示层：处理数据格式，加解密等等；</li><li>会话层：负责建立和维护会话；</li><li>传输层：负责提供端到端的可靠传输；</li><li>网络层：负责根据目标地址选择路由来传输数据；</li><li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li></ul><h5 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h5><ul><li>IP协议只负责发数据包，不保证顺序和正确性。</li><li>TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</li><li>许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</li><li>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</li></ul><h5 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h5><h6 id="Socket："><a href="#Socket：" class="headerlink" title="Socket："></a>Socket：</h6><p>Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP&#x2F;IP协议把数据传输到网络。一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。</p><ul><li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li><li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li></ul><h6 id="tcp编程使用socket模型"><a href="#tcp编程使用socket模型" class="headerlink" title="tcp编程使用socket模型"></a>tcp编程使用socket模型</h6><ul><li>服务器端用<code>ServerSocket</code>监听指定端口；</li><li>客户端使用<code>Socket(InetAddress, port)</code>连接服务器；</li><li>服务器端用<code>accept()</code>接收连接并返回<code>Socket</code>；</li><li>双方通过<code>Socket</code>打开<code>InputStream</code>&#x2F;<code>OutputStream</code>读写数据；</li><li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li><li><code>flush()</code>用于强制输出缓冲区到网络。</li></ul><h5 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h5><p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p><ul><li>服务器端用<code>DatagramSocket(port)</code>监听端口；</li><li>客户端使用<code>DatagramSocket.connect()</code>指定远程地址和端口；</li><li>双方通过<code>receive()</code>和<code>send()</code>读写数据；</li><li><code>DatagramSocket</code>没有IO流接口，数据被直接写入<code>byte[]</code>缓冲区。</li></ul><h5 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h5><p>当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code>80</code>端口和加密端口<code>443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了</p><p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。</p><ol><li><p>第一行总是<code>请求方法 路径 HTTP版本</code>，例如，<code>GET / HTTP/1.1</code>表示使用<code>GET</code>请求，路径是<code>/</code>，版本是<code>HTTP/1.1</code>。</p></li><li><p>后续的每一行都是固定的<code>Header: Value</code>格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p><ul><li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li><li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li><li>Accept：表示客户端能处理的HTTP响应格式，<code>*/*</code>表示任意格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示PNG格式的图片；</li><li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li></ul></li></ol><p>如果是<code>GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code>POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。<code>POST</code>请求通常要设置<code>Content-Type</code>表示Body的类型，<code>Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p><p><code>GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码</p><p><code>POST</code>请求的参数就没有长度限制，因为<code>POST</code>请求的参数必须放到Body中。并且，<code>POST</code>请求的参数不一定是URL编码，可以按任意格式编码</p><p>常见的发送JSON的<code>POST</code>请求如下：</p><pre><code class="hljs">  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/login</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>38<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bob&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></code></pre><p>HTTP响应也是由Header和Body两部分组成。</p><p>一个典型的HTTP响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>133251<br><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">...</span><br></code></pre></td></tr></table></figure><p>响应的第一行总是<code>HTTP版本 响应代码 响应说明</code>，例如，<code>HTTP/1.1 200 OK</code>表示版本是<code>HTTP/1.1</code>，响应代码是<code>200</code>，响应说明是<code>OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p><ul><li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li><li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li><li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li><li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li><li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应</li></ul><h4 id="JAVAweb"><a href="#JAVAweb" class="headerlink" title="JAVAweb"></a>JAVAweb</h4><h5 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h5><ul><li><p>由来：编写一个http服务器需要先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应，但是想要编写一个完善的http服务器需要考虑的点非常多，因此在JAVAEE平台中提供了Servlet API来处理HTTP请求，配合Web服务器实现Servlet API接口.</p></li><li><p>运行：在使用Maven导入Servlet API之后，打包出来的java程序是war程序，需要由能支持Servlet API的服务器来运行例如Tomcat、Jetty等。</p></li><li><p>使用：一个Web App就是由一个或者多个Servlet组成的，每个Servlet通过注解说明路径，处理GET、POST、PUT等请求时重写相应的doGet(),doPost()等方法即可。</p></li><li><p>关于多线程共用：对于每个请求，Web服务器会创建唯一的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例，因此，<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。</p></li></ul><h6 id="Servlet重定向"><a href="#Servlet重定向" class="headerlink" title="Servlet重定向"></a>Servlet重定向</h6><ul><li><p>含义：重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。</p></li><li><p>分类：重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存<code>/hi</code>到<code>/hello</code>这个重定向的关联，下次请求<code>/hi</code>的时候，浏览器就直接发送<code>/hello</code>请求了。</p></li><li><p>目的：重定向的目的是当Web应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。</p></li><li><p>使用：</p><p>HttpServletResponse<code>提供了快捷的</code>redirect()&#96;方法实现302重定向。如果要实现301永久重定向，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class="hljs-comment">// 301</span><br>resp.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;/hello&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h6 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h6><p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p><h5 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h5><p>HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。</p><h6 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h6><p>这种基于唯一ID识别用户身份的机制称为Session。每个用户第一次访问服务器后，会自动获得一个Session ID。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。JavaEE的Servlet机制内建了对Session的支持。</p><p>当一个用户登录成功后，我们就可以把这个用户的名字放入一个<code>HttpSession</code>对象，以便后续访问其他页面的时候，能直接从<code>HttpSession</code>取出用户名；服务器识别Session的关键就是依靠一个名为<code>JSESSIONID</code>的Cookie。在Servlet中第一次调用<code>req.getSession()</code>时，Servlet容器自动创建一个Session ID，然后通过一个名为<code>JSESSIONID</code>的Cookie发送给浏览器：</p><h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6><p>Servlet提供的<code>HttpSession</code>本质上就是通过一个名为<code>JSESSIONID</code>的Cookie来跟踪用户会话的。</p><p>创建一个新Cookie时，除了指定名称和值以外，通常需要设置<code>setPath(&quot;/&quot;)</code>，浏览器根据此前缀决定是否发送Cookie。</p><p>如果一个Cookie调用了<code>setPath(&quot;/user/&quot;)</code>，那么浏览器只有在请求以<code>/user/</code>开头的路径时才会附加此Cookie。</p><p>通过<code>setMaxAge()</code>设置Cookie的有效期，单位为秒，最后通过<code>resp.addCookie()</code>把它添加到响应。如果访问的是https网页，还需要调用<code>setSecure(true)</code>，否则浏览器不会发送该Cookie。</p><h4 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h4><p>JSP是一种文件以特殊格式存放一个HTML文件，其本质是就是一个Servlet但是不用配置映射路径，方便是不用在java文件中写html信息，但是缺点就是不能方便的在其中编写java类。现在已经很少使用。</p><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>JSP和java的Servlet优缺点刚好反过来了，于是出现了MVC结合这两者的优点。</p><p>Servlet处理业务逻辑，而jsp文件只负责展示信息，从Servlet中取信息传递给jsp文件，jsp文件负责展示，这种设计模式成为MVC。</p><p>但是这种模式仍不足，</p><ul><li>Servlet的接口仍然偏底层</li><li>业务逻辑最好由纯粹java类实现，而不是在servlet中</li><li>JSP对页面开发不友好</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java反射</title>
    <link href="/2024/03/06/java%E5%8F%8D%E5%B0%84/"/>
    <url>/2024/03/06/java%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>JVM会为每个加载的类创建一个Class实例，Class实例中包含该类的所有信息</p><p>我们可以通过调用Class类中的方法来获取该类的信息</p><h5 id="获取Class实例"><a href="#获取Class实例" class="headerlink" title="获取Class实例"></a>获取Class实例</h5><ul><li>直接通过静态变量获取</li><li>使用实例变量的getclass()方法</li><li>静态方法Class.forName(“完整类名”)</li></ul><h5 id="获取字段及信息"><a href="#获取字段及信息" class="headerlink" title="获取字段及信息"></a>获取字段及信息</h5><ol><li>获取字段<ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul></li><li>通过字段获取字段信息<ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul></li></ol><h5 id="获取方法及调用"><a href="#获取方法及调用" class="headerlink" title="获取方法及调用"></a>获取方法及调用</h5><ol><li><p>获取方法</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul></li><li><p>获取方法信息</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul></li><li><p>调用方法</p><p>使用Methord实例的invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-comment">// 获取String substring(int)方法，参数为int:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> String.class.getMethod(<span class="hljs-string">&quot;substring&quot;</span>, <span class="hljs-type">int</span>.class);<br><span class="hljs-comment">// 在s对象上调用该方法并获取结果:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (String) m.invoke(s, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>若Methor是静态方法则invoke的第一个参数是null</p></li><li><p>调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用</p></li><li><p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用学习</title>
    <link href="/2024/03/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Git是一个分布式版本控制系统（分布式指版本库储存在个人设备中，集中式的版本库位于中央服务器中，需要联网才能使用）。</p><h4 id="安装使用流程"><a href="#安装使用流程" class="headerlink" title="安装使用流程"></a>安装使用流程</h4><ul><li><p>Linux上直接使用软件包管理器安装或者编译安装即可，windows上直接在官网下载安装程序即可。</p></li><li><p>命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>创建版本库</p><p>*注意这里的操作是测试使用，如果想工作某个项目一般是先创建一个远程库，然后克隆至本地</p><ol><li><p>创建一个目录</p></li><li><p>git init即可将此目录变为可管理的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init [name]<br></code></pre></td></tr></table></figure></li><li><p>将文件添加到仓库（在仓库目录中执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add 文件名<br></code></pre></td></tr></table></figure></li><li><p>用命令<code>git commit</code>告诉Git，把文件提交到仓库（-m命令为此次提交填写说明<code>-m &quot;xxx&quot;</code>）</p></li></ol></li></ul><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ol><li><p><code>git status</code> 查看仓库状态</p></li><li><p><code>git diff &lt;文件名&gt;</code> 查看修改区别</p></li><li><p>版本回退</p><ul><li>使用 <code>git log</code> 查看更新日志</li><li>使用 <code>git reset --hard &lt;版本号&gt;  </code> (版本号可以是commit id的前几位，也可以用HEAD、HEAD^、HEAD~n(往上n个版本))</li><li><code>gut reflog</code> 查看每一次命令</li></ul></li><li><p>撤销修改</p><ul><li><code>git checkout -- &lt;文件名&gt;</code> 使工作区的修改撤回至暂存区&#x2F;(如果暂存区没有)版本库。（工作区是指你修改文件的地方，使用<code>git add</code>后修改被传至暂存区，使用<code>git commit</code>后修改被传至版本库）（应用于修改了还没add）</li><li><code>git restore &lt;file&gt;</code> 将文件的修改撤销至暂存区，并清空暂存区（应用于修改了还没add且上一次add还没commit）</li><li><code>git restore --satge &lt;file&gt;</code> 将暂存区清空但不修改工作区修改（应用于add了还没commit）暂存区&lt;–工作区</li><li><code>git reset HEAD &lt;file&gt;</code> 将暂存区的修改撤销至版本库（应用于add了还没commit）暂存区&lt;–版本库</li></ul></li><li><p>删除文件</p><ul><li><p>删除工作区文件后继续删除版本库中文件</p><p><code>git rm &lt;file&gt;</code>  then  <code>git commit -m &lt;message&gt;</code> </p></li><li><p>删除工作区后恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -- test.txt<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>有两种选择</p><ol><li>搭建一个个人的Git服务器，这种服务器别人无法看见；</li><li>使用Github免费仓库，其他人可见。</li></ol><h5 id="关联至github远程仓库"><a href="#关联至github远程仓库" class="headerlink" title="关联至github远程仓库"></a>关联至github远程仓库</h5><p>需要使用SSH加密所有需要获取个人的私钥和公钥，若没有则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>将本地仓库与远程仓库关联，在本地仓库中执行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:用户名/远程库名.git<br></code></pre></td></tr></table></figure><p>把本地库的所有内容推送到远程库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br></code></pre></td></tr></table></figure><p>上述指令是将本地的分支master推送到远程仓库origin。-u是关联的参数。</p><h5 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h5><p><code>git remote -v </code>查看远程库信息</p><p><code>git remote rm &lt;name&gt;</code> 解除与远程库的绑定关系</p><h5 id="git-clone-克隆远程库"><a href="#git-clone-克隆远程库" class="headerlink" title="git clone 克隆远程库"></a>git clone 克隆远程库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:用户名/远程库名.git<br></code></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><h5 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev 或者<br>$ git switch -c dev<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch dev<br>$ git checkout dev<br>或者<br>$ git branch dev<br>$ git switch master<br></code></pre></td></tr></table></figure><p>使用 <code>git branch</code> 查看当前分支</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>先切换回master分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev<br></code></pre></td></tr></table></figure><p>若是master和dev都修改过，则可能产生冲突，需要先消除冲突。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev<br></code></pre></td></tr></table></figure><h5 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br>$ git stash apply//不删除stash内容恢复现场<br>$ git stash drop//删除stash内容<br>$ git stash pop//删除stash内容恢复现场<br></code></pre></td></tr></table></figure><h5 id="将相同的修改应用至别的分支"><a href="#将相同的修改应用至别的分支" class="headerlink" title="将相同的修改应用至别的分支"></a>将相同的修改应用至别的分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commit ID&gt;<br></code></pre></td></tr></table></figure><h5 id="丢弃一个没有被合并过的分支"><a href="#丢弃一个没有被合并过的分支" class="headerlink" title="丢弃一个没有被合并过的分支"></a>丢弃一个没有被合并过的分支</h5><p>通过<code>git branch -D &lt;name&gt;</code>强行删除</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><ul><li><p>切换到分支然后<code>git tag &lt;name&gt;</code></p></li><li><p>使用 <code>git tag</code> 查看所有标签</p></li><li><p>给某次提交打标签 <code>$ git tag &lt;name&gt; &lt;commit ID&gt;</code> </p></li><li><p>删除标签 <code>git tag -d &lt;name&gt;</code> </p></li><li><p>推送某个标签到远程<code>git push origin &lt;tagname&gt;</code> 或者 <code>git push oringin --tags</code> </p></li><li><p>从远程删除标签 <code>$ git push origin :refs/tags/&lt;name&gt;</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
